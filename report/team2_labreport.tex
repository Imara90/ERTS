%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% In 4073 Embedded Real-Time Systems Course report
% Team 2: Daniel Lemus Perez, Diogo Monteiro and Imara C.T.M. Speek
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}
\usepackage{float}

\usepackage{caption}
\usepackage{graphicx} % Required for the inclusion of images
%\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 
\usepackage{anysize}
\marginsize{2cm}{1.5cm}{0.5cm}{2cm} % decrease the margins
\usepackage{subcaption}

\usepackage{xcolor}
\newcommand\worries[1]{\textcolor{red}{#1}} %add command to specify worries in red
\newcommand\todo[1]{\textcolor{blue}{#1}} % add command to specify todo in blue

\usepackage[toc, page]{appendix} % to include appendices
\usepackage{listings} % to include source code

%\setlength\parindent{0pt} % Removes all indentation from paragraphs

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)

%\usepackage{times} % Uncomment to use the Times New Roman font

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{IN4073 Embedded Real-Time Systems \\ QR Lab report - Team II} % Title

\author{Diogo \textsc{Monteiro}, Daniel S. \textsc{Lemus} and Imara C.T.M. \textsc{Speek} \\
		4323688 870754 1506374} % Authors' names

\date{\today} % Date for the report

\begin{document}

\maketitle % Insert the title, author and date

% abstract of 10 lines maximum specifying the specific approach and results
 \begin{abstract}
Developing a real-time embedded system to pilot a Quad-Rotor UAV (QR) rises many challenges in a wide range of subjects. All the software developed was coded in embedded C, C++ and C in the PC and  implemented through the X32 soft core on the FPGA. The Pc2Fpga communication protocol uses a fixed packed length of 7 bytes, including a starting flag byte and checksum byte. The controller created includes a Kalman filter and Butterworth filter for sensor data handling, having a closed-loop cycle of approximately 867 $\mu s$. A proportional (\texttt{P}) controller was incorporated for \textit{yaw-controlled mode} and a proportional derivative (\texttt{PD}) controller, build through a cascaded \texttt{P} controller for \textit{full control mode}. Although a proficient code was elaborated, full controlled flight was not accomplished due to insufficient tuning of the filters.

 \end{abstract}

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%	include the problem statement
%----------------------------------------------------------------------------------------

\section{Introduction}
\label{sec:introduction}
This project aims to familiarize students with the multidisciplinary skills of embedded system engineering, specifically the designs of an embedded software that controls and stabilizes an unmanned aerial vehicle (UAV), a Quad-Rotor UAV or 'QR'. A FPGA platform is implemented in the prototype to provide a versatile experimentation platform for embedded system development. The FPGA comes with a \texttt{X32} soft core running at 2 MIPS. 
This FPGA is connected through a serial link connection with the PC and a QR link to the Atmega micro controller that provides the sensors and actuators as will be explained in the next section. These link interfaces require careful consideration for the communication protocols as will be discussed in Section \ref{sec:communication}. This low-cost approach introduces measurement errors, reduced size and performance of the FPGA and will present an excellent opportunity for programming embedded systems in a challenging and real application context when dealing with limited-performance components.  


%----------------------------------------------------------------------------------------
%	ARCHITECTURE
%	Specify all software components + interfaces
%----------------------------------------------------------------------------------------

\section{Architecture}
\label{sec:architecture}

\begin{figure}[h]
\centering
	\includegraphics[scale = .55]{Figures/Architecture.pdf}
	\caption{Software architecture Scheme}
	\label{fig.Architecture}
\end{figure}

The schematic in Figure \ref{fig.Architecture} describes the software architecture implemented for the interfacing of the Pc/Fpga link at 115k2bps and the Fpga/Qr link at 500kbps. The 100 MHz Trenz TE0300-01BMLP 1600K gates Spartan-3E FPGA comes with the free development X32 soft code allowing the system to be developed in C. The PC acts as a user interface as well as a ground station to read the joystick and keyboard commands. It transmits commands and receives telemetry from the ES while visualizing and eventually storing the data on file after operation through a duplex serial RS232 port. The Atmel AtMega1280 microcontroller interfaces between the 4 brushless Robbe motors (Roxxy BL outrunner 2827-34) controlled by AeroVinci's v2 motor controller and STMicroelectronics LIS344AL accelerometers and Inversense IDG500 gyroscopes and the X32 soft core. 


%----------------------------------------------------------------------------------------
%	IMPLEMENTATION
%	How you did it and who did what
%----------------------------------------------------------------------------------------

\section{Implementation}
\label{sec:implementation}

This section introduces the implementation of the functionalities implemented in the system. These concern, GUI communication protocols, safety measures, speed enhancements and basic functionalities.


%-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%GUI
\subsection{GUI}
A simple GUI is designed to control the QR (Figure \ref{fig.GUI}) using QT creator allowing for multi-platform deployment. Users can interact with the QR through the GUI with the keyboard and the joystick as described in the lab assignment. The GUI's functionalities are described in Table \ref{tbl:GUIButts}. 

\begin{figure}[ht]
\centering
	\includegraphics[scale=0.35]{Figures/GUI.png}
	\caption{Designed User Interface}
	\label{fig.GUI}
\end{figure}

\begin{table}[ht]
\centering
\begin{tabular}{|c|c|}
\hline 
\textbf{Button} & \textbf{Functionality} \\ 
\hline 
\hline 
Connect / Disconnect & Establishes PC Link (through RS232) \& enables the \emph{Start Sending} button  \\
\hline 
Start/Stop Sending & Display Joystick/Keyboard commanded inputs and Telemetry. 
\\ & Disables/enables the connect button (now labeled as Disconnect).
\\ & Enables \emph{Abort} and \emph{Download DataLog}.
\\
\hline 
Download DataLog & \texttt{EXIT\_MODE} is sent to the QR and data is received and stored in a \texttt{.txt} file
\\ & \emph{Start/Stop Sending} button is disabled while data is retrieved\\
\hline 
Abort & \texttt{ABORT\_MODE} is sent to the QR setting all engines to zero\\ 
\hline 
\end{tabular} 
\caption{GUI functionalities}
\label{tbl:GUIButts}
\end{table}

Telemetry data is shown in 3 display controls (QR column with r, phi, theta) next to the commanded values \texttt{REFERENCES} which are only displayed in \texttt{FULL\_CONTROL} mode. All commanded signals shown in the MODE, Lift, Roll, Pitch, Yaw, P, P1 and P2 controls. The \texttt{P} values are only changed in \texttt{YAW\_CONTROL} and \texttt{FULL\_CONTROL} modes as explained in Section \ref{sec:modeselection}. Four extra indicators show the expected motor speed (Along with a QR schematic for easier understanding). The PC calculates these motor speed values in function clones from the FPGA functions, locally on the PC by using the same input data. As a safety measure, the QR must be set in \texttt{SAFE\_MODE} before communication is stopped (using the \emph{Start/Stop Sending} button). If the user terminates the program, \texttt{SAFE\_MODE} is set in the QR and the RS232 port is closed.

%-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Memory allocation in the FPGA}
\textbf{Imara} implemented circular buffers,these buffers are preferred as they only overwrite current values when packets are received faster than they are handled, which is something we can adjust. The buffers are type defined as a \texttt{CBuffer struct} including its \texttt{size}, the oldest element \texttt{start}, its newest element \texttt{end} and a vector of \textsc{byte} elements \texttt{$^*$elems}.

The circular buffers are initialized for the transmitting, the receiving buffer and the data log buffer which needs a different size range. To generally allocate memory, the \texttt{calloc()} function would be used. The \textsc{x32} library however does not support these functions and needs a work around. To accommodate for this, global arrays with the preferred circular buffer sizes are initialized upon the start of the system. In stead of initializing the vector of elements of the circular buffer in the \texttt{cbInit()} function, we pass the address of the matching global array and position the vector of elements in the address of the array.  To make sure the circular buffers are empty when entering the main \texttt{while()} loop, the buffers are cleaner using the \texttt{memset()} function in \texttt{cbClean()} as coded by \textbf{Imara}.

The writing macro \texttt{cbWrite} works by writing a value to the newest element of the circular buffer, repositioning the pointer to the current newest element. It then double checks whether the buffer is full and if so overwrites. The checksum is then appended because the address of its variable is passed in the function. Although changing the functionality to a macro decreased the time for saving in the buffer from 91 $\mu$s to 64 $\mu$s and the total amount of time to 1738 $\mu$s to 984 $\mu$s. Sending a single byte previously took 150 $\mu$s to perform, while it only takes 83 $\mu$s using the macro. These timing specifications are further elaborated in Section \ref{sec:profiling}.

%-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
% All info considering communcation protocols
\subsection{Communication Protocols}
\label{sec:communication}
As mentioned in Section \ref{sec:architecture}, the different interfaces require different communication protocols to perform optimal communication. This section discusses these protocols. 

%-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Pc2Fpga}
In order to efficiently transmit  data from the PC to the FPGA, a simple and compact communication protocol was implemented. It consists of a fixed length 7 bytes packet, including a starting byte \textbf{0x80}, 5 parameters and a checksum to ensure a reliable communication (Table \ref{tbl:PkgDefinition}). Serial port communication is set to 115.2 kbps, 8n1 (1 Start bit, 8 data bits and 1 stop bit), meaning that each byte sent is composed by 10 bits. Each byte can be sent through the port at 11.5 kB/s (87 $\mu$s). The total number of bytes sent/received by the pc-$>$ QR link (including telemetry (See. \ref{sec:modeselection})) is 14, which can be handled at 1.2 ms, being fast enough to update user commands.

In order to be able to receive on the RS232 line, the \texttt{INTERRUPT\_PRIMARY\_RX} has to be enabled. This is done in the initializing of the interrupts in the main loop. 

\begin{table}[ht]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline 
0x80 & MODE & LIFT/- & ROLL/P & PITCH/P1 & YAW/P2 & CHECKSUM \\ 
\hline 
\end{tabular} 
\caption{Packet Definition in bytes}
\label{tbl:PkgDefinition}
\end{table}

The packet structure is composed of
\begin{itemize}

\item{\emph{Starting Byte} \textbf{0x80}, none of the parameters nor the checksum are allowed to have this value.}

\item{\emph{Mode} is set in the second byte as an unsigned char.}

\item{\emph{Lift} is scaled from $[0-255]$ excluding 128 (\textbf{0x80}).}

\item{\emph{Roll}, \emph{pitch} and \emph{yaw} are scaled in the range $[-127,127]$, and then type-cast to unsigned char. The same range is used to scale the control gains (\emph{P} (for yaw control), \emph{P1} and \emph{P2} (for full control)).}

\item{\emph{Checksum} is calculated as a two's complement addition of all parameters (exluding the starting byte). The \textbf{0x80} value is handled and changed to \textbf{0x00}.}

\end{itemize}

The parameters encapsulated in the packet depend on the selected mode. \emph{Panic, Manual, Calibration,Yaw Control} and \emph{Full Control} modes include \emph{lift}, \emph{roll}, \emph{pitch} and \emph{yaw} as parameters. The \emph{P} mode includes an empty byte $'0'$, \emph{P} (for yaw control) and \emph{P1} and \emph{P2} (for full control) gains as parameters (Table \ref{tbl:PkgDefinition}). Although \emph{lift}, \emph{roll},\emph{pitch} and \emph{yaw} are transmitted for safe, panic and calibration modes, they are not acknowledged by the FPGA. Data coming from the joystick and keyboard are scaled in $[0-255]$ range and encapsulated in a single byte (\emph{unsigned char}) per parameter.
%Although data from the joystick comes in the [$2^{15}$,$2^{15}-1$] range, a single byte is used for each parameter. This is enough taking into account that high sensitivity from the joystick is not needed and rather undesirable (may introduce noise).

The data structure is implemented in the \emph{Package.h} file. This structure includes functions to initialize, set parameters into the packet and calculate the checksum. Some extra functions are included to clip the data to the [-127,127] range and handle \textbf{0x80} exceptions. This simple communication protocol structure allows for more efficiently decoding in the FPGA, handling always the same packet length.

%-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Mode selection}
\label{sec:modeselection}
To assess the mode changes requested by the user, \textbf{Diogo} created the \texttt{mode\_selection()} function which is executed between readings of the keyboard and the communication packet creation. The QR operation is always started in \textit{safe mode} and any change between modes must first pass by this safe state. Exception is made to access \textit{panic mode} or \textit{abort mode} as a safety measure. In order to change from \textit{safe mode} to an intended control mode there are two main checks: \textit{Lift} and the sum of the engine values must be equal to $0$, which is equivalent to have all the 4 engines set to $0$. The latter check is done by setting the \texttt{Engines\_Null} flag in the (\textbf{TELEMETRY FLAG}), received in the telemetry packet, a byte appended in the telemetry send by the QR. 

Moving to both \textit{yaw-controlled mode} and \textit{full control mode} requests an extra check to assess if the sensors calibration was already performed using the \texttt{Calibration\_Done} flag. Changing between a control mode and the \textit{P control mode} is enabled to adjust the proportional gains (\textit{P,P1,P2}) of the controllers. Mode changes to \textit{safe mode} are performed automatically when \textit{panic mode} or \textit{calibration mode} have completed its functionality. This \texttt{Safe\_Mode\_Request} is also appended in the telemetry flag. 

Any time an attempt is made to change mode and all the requirements are not fulfilled, the communication packet sends the previous operating mode which is saved in the variable \texttt{prev\_mode} locally on the PC. Including the mode selection in the PC side allows to avoid all the needed checks in the FPGA. The cost of including one extra byte (\textbf{TELEMETRY FLAG}) in the telemetry packet revealed to be a rather advantageous solution in terms of processing time in the FPGA.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline 
DC & DC & DC & DC & DC & ENGINES NULL & SAFE MODE REQUEST & CALIBRATION DONE \\
\hline 
\end{tabular} 
\caption{TELEMETRY FLAG Definition in Bits}
\label{tbl:TelFlagDef}
\end{table}

%-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Fpga2Pc}
To supervise the behavior of the QR, telemetry is send. To ensure a reliable communication a starting byte and checksum as discussed in the next section are appended in the packet. The telemetry sends the most important features to supervise: the angular rate $r$ for yaw-control and the angular velocities $\phi$ and $\theta$ to distinguish the motion of the QR. To not loose any precision we need 2 bytes for Phi and theta as their data is 18 bits long, but they never reach their full potential as has been tested priorly. Along with these parameters, the status of the FPGA, appended in the \texttt{TELEMETRY\_FLAG} is sent as defined in Table. \ref{tbl:TelPkgDefinition} 

As the final telemetry coded by \textbf{Imara} takes 904 $\mu$s to assign and send, it will claim the RS232 line, slowing down the entire process. For this reason a polling technique was implemented. The \texttt{send\_telemetry()} is called in every while loop, but checks whether or not the defined \texttt{POLLTIMEMS} of 200 $ms$ is passed. If this is the case, the telemetry flag is set according to the sum of the engines. The appropriate parameters are then written to the transmitting circular buffer using the macro function \texttt{cbWrite()} as written by \textbf{imara} which immediately updates the checksum by passing the address of the local variable. If the checksum contains the starting byte \textbf{0x80}, it is appended to \textbf{0x00}. The checksum is then added to the packet after which a while loop iterates until the transmitting buffer is empty (\texttt{txcb.end == txcb.start}). Until then it waits indefinitely for the RS232 to change its status register to \texttt{X32\_rs232\_stat \& 0x01}, indicating it is ready to send the next byte upon which it does so by using the macro \texttt{cbGet()} as written by \textbf{Imara} which writes the current value of the transmitter buffer to the address of the \texttt{X32\_rs232\_data} RS232 data register, initializing the transmission of the written byte. In order to be able to send on the RS232 line, the \texttt{INTERRUPT\_PRIMARY\_TX} has to be enabled. This done in the initializing of the interrupts in the main loop. 

\begin{table}[ht]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline 
0x80 & r & phi $>>$ 8 & phi & theta $>>$ 8 & theta & TELEMETRY FLAG & CHECKSUM \\
\hline 
\end{tabular} 
\caption{Telemetry Packet Definition in Bytes}
\label{tbl:TelPkgDefinition}
\end{table}


Initially the \texttt{send\_telemetry()} coded by \textbf{Imara} send only the first byte of the telemetry, causing the initiation of the \texttt{isr\_rs232\_tx()}. The next byte to be send in the circular buffer would this way be put in line waiting to be handled by a scheduler, causing no delays for other important ISRs. This would initiate a new interrupt for every byte send until the buffer was empty. Due to a shortage of team members and time we decided to send all telemetry in one go instead

%-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
% Reliable communication
% 

\subsection{Communication properties}
\subsubsection{Reliability} 
To ensure a \emph{reliable communication}, the sent packets are appended with a checksum.  This checksum is calculated at both the PC and the QR. When the locally calculated checksum does not match the send checksum, the package is regarded as faulty and discarded. The checksum in the \textsc{Pc2Fpga} protocol is calculated using a \emph{two's complement addition checksum} as it has been used before in a previous project by \textbf{Daniel}. The checksum calculation used in the telemetry and data logging written by \textbf{Imara} uses the \textsc{XOR} checksum.  

The two's complement method takes 22 $\mu$s for every addition and requires a complement taking 5 additional $\mu$s while the \textsc{XOR} method takes 22 $\mu$s for every \textsc{XOR}'ing. Both checksums have a \emph{Hamming Distance} of 2, detecting all one-bit errors, but not all two-bit errors. This happens when an even number of bit errors occurs in the same bit position of the checksum computational block. The two's complement addition can be seen as an improvement of the \textsc{XOR} checksum as it mixes between bit positions of the data-blocks as a result of the bit-by-bit carry outs of the additions. As most of the control loop delay is caused by the X32 code, we want to limit the amount of instructions. Because of this and it's data independence we decided to use the \textsc{XOR} checksum 

\subsubsection{Dependability}
Whenever the PC link is broken or disconnected, the code should immediately signal the error and enter panic mode. \textbf{Imara} coded this using a communication counter \texttt{commflag} which is set to zero whenever a package is received in the interrupt service routine of the RS232 RX of the FPGA. Whenever the counter exceeds the threshold \texttt{commthres}, the mode is set to \texttt{PANIC\_MODE}. 

\subsubsection{Robustness}
To handle the fixed point arithmetic constraint in the fpga, \textbf{Daniel} created an adapted multiplication routine which ensures a 14 bits precision. This was used for both Butterworth filter and Kalman filter algorithms. Moreover, due to the risk of loss of precision when applying the gain parameters in the controllers an extended   arithmetic was used. For instance, in the \textit{yaw-controlled mode} the \textit{yaw momentum} \texttt{N} computation applies \texttt{N = P*r\_ref - P*r} instead of \texttt{N = P*(r\_ref - r)}.
Not least important, during the development of the code the X32's divide-by-zero and integer overflow interrupts were applied several time to assess if any arithmetic error was occurring.
%-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
% Safety mode, emergency stop, stalling proof, robust to noise, reliable communication, 
% dependability, robustness

\subsection{Safety features}
An extra \texttt{abort\_mode} was created by \textbf{Diogo} to distinguish between directly dangerous situations where the FPGA should shut down the engines and shut down and situations where the system can reduce engine values in a controlled manner such as the \texttt{panic\_mode} provides.

To prevent stalling to occur in the brushless engines, a \texttt{check\_motor\_ramp()} function is called in the PC after the \texttt{mode\_selection()} performs the mode selection. This function written by \textbf{Daniel} clips the ramping up of the engines to a set maximum value for increasing and decreasing of the engine values. This is done by comparing current \texttt{lift} control values with a \texttt{prev\_lift}. 

%-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%   Datalogging
\subsection{Data Logging}

Data logging as coded by \textbf{Imara} is used to verify the filtering/controller behaviour, as well as QR behaviour in general. The \textsc{store\_data()} function polls in the same way as the \texttt{send\_telemetry()} function does, but instead every \textsc{DATASTORETIMEMS} of 150 $ms$. The 33 bytes packet is composed of a starting byte (\textbf{0x80}), 16 parameters (31 bytes) and a checksum. Logged data includes a timestamp (1 byte), MODE, Lift, Roll, Pitch and Yaw (1 byte each), motor commanded speeds (2 bytes each), sensor normalized data (1 byte each) excluding acceleration reading in Z direction, phi and theta angles (2 bytes each), p and q angles (1 byte each), P, P1 and P2 control gains (1 Byte each) and control time (1 byte). The packet is composed in the \textsc{store\_data()} function. 

In contrary to the telemetry, the data log is send on command when the \emph{exit mode} is triggered (Pressing Del key or clicking the Data Log button in the GUI). The FPGA exits the while loop and starts sending the stored data in the \textsc{send\_data()} function which keeps sending until the circular data log buffer is empty. In the mean time the PC stops writing in the port and starts receiving from the FPGA. As the data is received, the PC checks for the starting byte (\textbf{0x80}) and stores the subsequent bytes until the expected size is reached (33 bytes). Once the complete packet is stored, the checksum is verified and the packet is written into a text file. All packets are separated by a CR and the starting byte is excluded (as the packet is verified before is written into the file).

A matlab script is used to decode and visualize the logged signals. It decodes the signals to the original values using the function \textsc{typecast}. Additionally the time-stamp is calculated as the integral of the recorded time-stamp (Time-stamp was recorded as the time interval in between measurements in order to save storage bytes). Several plots can be generated once the data is processed. A sample of the generated plots can be seen in Figure \ref{fig:YawControl}


%-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%   Filtering
\subsection{Filtering}
\label{sec:filtering}

QR sensor signals must be filtered and bias-cleared before they are feed in the controller. Figure \ref{fig.Noise} shows signals in steady state coming from the accelerometer and gyroscope. Two filter options are explored to perform the signal reconditioning: Butterworth Filter and Kalman Filter developed by \textbf{Daniel} and \textbf{Diogo}, respectively.

The only control mode that makes use of the sensor filtered values is the \textit{full control mode}, since the \textit{yaw rate} \texttt{r} for the \textit{yaw control mode} can be read directly from the gyro sensor along the respective axis. Hence, it was decided to include the sensor reading and filtering in the main \texttt{switch case} along with the \texttt{case FULL\_CONTROL\_MODE}. Other options were considered such as including the sensor handling in a timer interrupt or in the \texttt{isr\_qr\_link} interrupt. However, for both cases sensor reading and filtering would be performed even in unnecessary conditions. Moreover, setting it just before the \texttt{full\_control\_mode()} function allowed to keep the sensor handling at an approximately constant frequency, what is of importance for a good performance of the filters. In the case of changing to a different mode, the filter's constants are reinitialized so that erroneous values are not obtained if \textit{full control mode} is executed after.

\begin{figure}[ht]
\centering
	\begin{subfigure}[b]{0.49\textwidth}
  		\includegraphics[trim = 0mm 50mm 0mm 40mm, width=\linewidth]{Figures/Noise}
		\caption{Accelerometer vs Gyro signals noise comparison}
		\label{fig.Noise}
  \end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}	
		\includegraphics[trim = 0mm 50mm 0mm 40mm, width=\linewidth]{Figures/NoiseComp}
		\caption{Cutoff Frequency effect in a $1^{st}$ order Butterworth filter}
		\label{fig.NoiseComp}
	\end{subfigure}
	\caption{}
\end{figure}

\subsubsection{Butterworth Filter}

A first order Butterworth filter is used to perform noise reduction. This noise reduction can be regulated setting the cutoff frequency. Lower cutoff frequencies will lead to a much smoother signal with delay as trade-off. In contrast, higher cutoff frequencies results in a synchronized signal with still some noise (Figure \ref{fig.NoiseComp}). Although a lower cut frequency (10Hz) lead to a delayed signal, the phase shift for a Butterworth $1^{st}$ order is less than $90^{o}$ at the cut frequency, making it suitable for the QR application. 


Implementation of a $1^{st}$ order Butterworth filter is straightforward. Given the signal sample frequency and the desired cutoff frequency, a set of constants are calculated. Using these constants the filtered signal is reconstructed out from the raw sensor values and the previous filtered value.

\begin{equation}
	 B_0 y_k = A_0 x_k + A_1 x_{k-1} + B_1 y_{k-1}
	 \label{eq:Butt1st}
\end{equation}

Equation \ref{eq:Butt1st} shows the update formula for a 1st order Butterworth filter, where $x$ and $y$ are the raw and filtered values respectively, $A_0$, $A_1$, $B_0$ and $B_1$ are the constants for a $1^{st}$ order Butterworth filter, $k$ and $k-1$ represent the current and previous measurement.

The calculated constants for the $1^{st}$ order Butterworth are rational numbers and a proper scaling is applied in order to compute the multiplication with the measured and filtered values (the FPGA soft core does not handle floating point numbers). A 14 bit fix point arithmetic is applied in this case to compute the constants (This is multiply by $2^{14}$ and round the number as seen in Table \ref{tbl:ButtConstants}).

\begin{table}[ht]
\centering
\caption{Telemetry Packet Definition}
\begin{tabular}{|c|c|c|c|c|}
\hline 
 & $A_0$ & $A_1$ & $B_0$ & $B_1$ \\ 
\hline 
Real Values & 0.0242 & 0.0242 & 1 & -0.9515 \\ 
\hline 
14 Bit Fix Point & 396 & 396 & 16384 & -15590 \\ 
\hline 
\end{tabular}
\label{tbl:ButtConstants}
\end{table}

Once the values are scaled properly multiplication can be computed as the product of two integers dividing the result by $2^{14}$ by shifting. The outcome of the multiplication is used to compute the filter described in equation \ref{eq:Butt1st}. To generate a speed up, a marco was coded by \textbf{Imara} for this \texttt{mult(a, b)} function. 

\subsubsection{Kalman Filter}

The Kalman filter is applied for correction of the sensor reading errors related to gyroscopes drift. An extra effort for noise reduction is done by using the Butterworth filter, as stated in the previous section.

A first approximation of the angle and associated rate is found by directly reading the accelerometer and gyroscope values, respectively. An estimate of the angle is attained by integrating the angle rate using the constant \texttt{P2PHI}. Then, an iterative correction of that value is performed by using constant \texttt{C1} and comparing the actual estimate and accelerometer reading. Also the value obtained for the angle rate is corrected in a similar way by the constant \texttt{C2}, which will influence the rate integration in the following iteration. By adjusting the values of the referred constants, we define the weight or influence that each sensor reading has in the angle and rate computation. This continuous iterative process will correct for both accelerometer noise and gyroscope drift in the long term.

In order to achieve a faster algorithm the constants \texttt{C1} and \texttt{C2} are defined as a power of $2$ value such that the introduced corrections can be performed by a simple shift right. In the integration step of the algorithm the constant \texttt{P2PHI} was first implemented by using an estimate value and applying the fixed point arithmetic, defined in the previous section. Later, for easing the tuning process it was also tried to implement the integration by applying shift rights to the angle rate instead of using the multiplication by \texttt{P2PHI}. The tuning procedure of the Kalman Filters was not completed, therefore final values of the constants were not found as will be explained in Section \ref{sec:results}.


%-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%   Control Modes
\subsection{Control Modes}

\label{sec:safemode}
The \emph{safe mode} is the initial mode in which the QR operates and has to be accessed in between switching modes with the exception of \texttt{Panic\_mode} and \texttt{Abort\_mode}.. \textbf{Imara} coded the safe mode function in the matching header file in which the FPGA's status is updated in the \texttt{telemetry\_flag}. This safe mode and the \texttt{mode\_selection()} function ensures that no illegal control values are send to the engines when switching modes and is responsible for de-energizing the four rotor engines. The engine values are decreased using a \texttt{SAFE\_JUMP} value of 5 to avoid stalling of the engines whenever the FPGA operates in safe mode as determined in the \texttt{switch case} in the \texttt{main} function. The mode can be accessed by pressing '$0$' in the keyboard.\\

\textit{Panic mode} developed by \textbf{Diogo} can be accessed by pressing '$1$' in the keyboard. The main purpose of this function is to allow the safe landing of the QR in a lost of control scenario. To achieve this, a mean of the actual engines values is computed and in case it is higher than an experimentally defined \texttt{LIFT\_THRESHOLD}, a progressive balance of the four engines is accomplished through changes by a value of $30$ (\texttt{ENGINE\_STEP}) until the reference threshold is attained for each engine. The value \texttt{LIFT\_THRESHOLD} was found by increasing lift until the QR was about to hover.  In case the mean value of the engines is superior to the \texttt{LIFT\_THERSHOLD}, the final reference becomes the computed mean. This was done to avoid sudden increases of engines thrust whenever panic state is reported. The value chosen for the \texttt{ENGINE\_STEP} revealed to be fairly adjusted to the requested engine speed changes and at the same time stalling proof.

Finally, when all the engines are at the same speed a delay time of 2 seconds is performed in order to allow the balancing of the QR. After, the \texttt{TELEMETRY\_FLAG} is updated to request a change to \textit{safe mode}.\\

\textit{Manual mode} developed by \textbf{Diogo} can be accessed by pressing '$2$' in the keyboard. In this mode a direct mapping between the received information and the engine values was designed. A initial base value to the engines is assigned using the \textit{Lift} information, by defining a scaling between $[0-255]$ and $[0-\text{\texttt{ENGINE\_LIMIT}}]$. In order to obtain a faster increase of the engines until an approximate hover state is attained, two different linear scaling were defined: one for \textit{Lift} values up to $75$ (\texttt{LOW\_LIFT\_CONVERSION}) and second for the rest of the range (\texttt{HIGH\_LIFT\_CONVERSION}).

The other received parameters (\textit{Roll, Pitch, Yaw}) will then apply offsets to the base value defined, such that the intended movement by the user can be performed. For the case of \textit{Roll} and \textit{Pitch}, only one engine is affected for each information. This allows to approximately maintain a constant lift force in the QR. For the \textit{Yaw} case and due to the same reason, all engines suffer symmetric offsets. The scaling of the latter parameters is done between $[-127,127]$ and $[-50,50]$, which is defined in the code using the macro \texttt{ROLLPITCHYAW\_ENGINE\_LIMIT}. 

Note for the fact that when the reference value is negative($[-127,0[$), a signing typecast is performed since the decoded information in the fpga is unsigned. This typecast is also performed for the controlled modes.\\

\textit{Calibration mode} developed by \textbf{Diogo} can be accessed by pressing '$3$' in the keyboard. In order to compute the calibration values of each sensor, the function \texttt{calibration\_mode()} is called continuously until 256 (\texttt{CALIBRATION\_THRESHOLD}) values of each sensor reading are saved and summed in the array variable \texttt{OFFSET\_x0[i]} with 6 positions (6 sensors). When the sum is finished, what is controlled by the counter \texttt{calibration\_counter}, a shift right of $8$ ($2^8=256$) bits is performed to obtain the final offset calibration values. At this point the \texttt{TELEMETRY\_FLAG} is also updated to request a change to safe mode in the PC and inform that calibration was already performed.\\

\textit{Yaw-Controlled Mode} developed by \textbf{Diogo} can be accessed by pressing '$4$' in the keyboard. For the development of this mode, a linear approximation of the QR dynamics was used in order to avoid the necessity of creating a square-root routine needed for the fidelity model of the system, presented in the assignment description. Despite the approximation, the controller behaviour proved to not be deeply affected and still bringing the reference error to null.
For this control mode the lift, roll and pitch movements are still considered manually controlled, therefore a similar scaling to the one used in \texttt{manual\_mode()} was applied. However, instead of a direct scaling of the engines values here it is done for the \textit{lift force} \texttt{Z} ,\textit{roll momentum} \texttt{L} and \textit{pitch momentum} \texttt{M}. All the definitions used for the scaling constants were based on the values used in the manual mode, which were tuned experimentally. This way, the expected behaviour of the QR is closely related to the one applied in the \textit{manual mode}, except for the yaw motion.

For the \textit{yaw momentum} \texttt{N} the proportional control loop is applied based on the sensor reading of the yaw rate \texttt{r}. This is done by a direct reading of the sensor \texttt{x0[5]} corrected by the calibration. Having the force and momentums defined, the inversion of the linearized system dynamics is performed in order to obtain the engine values. \\

\textit{Full Control Mode} developed by \textbf{Diogo} can be accessed by pressing '$5$' in the keyboard. This mode follows the same algorithm used for the \textit{yaw-controlled mode} but with only a direct scaling for the \textit{lift force} \texttt{Z}. Also the definition of the \textit{yaw momentum} \texttt{N} is the same used in the previous controlled mode. 

For both the \textit{roll momentum} \texttt{L} and \textit{pitch momentum} \texttt{M}, a proportional (\texttt{P1}) and derivative (\texttt{P2}) controller is applied based on the actual values of the roll and pitch dynamic angles and rates. This angular states are provided by the sensor reading after passing through the filters, as explained in \ref{sec:filtering}. In the end the linearized system dynamics are inverted and the engines values computed.\\

\textit{P Control Mode} developed by \textbf{Diogo} can be accessed by pressing '$6$' in the keyboard. This mode is intended to be accessed when an adjustment of the controllers parameters is requested for tuning purposes. Initially the parameters are defined using the macros \texttt{PCONTROL\_INIT}, \texttt{P1CONTROL\_INIT} and \texttt{P2CONTROL\_INIT}. When this mode is entered an offset can be applied to the initial values based on the received in the communication packet. The range of change is set between $[\text{\texttt{\_INITIAL}}-127,\text{\texttt{\_INITIAL}}+127]$.\\

\textit{Abort/Exit Mode} developed by \textbf{Diogo} can be accessed by pressing \texttt{DEL} in the keyboard or pressing 'strike' button in the joystick. The option to use \texttt{DEL} key instead of \texttt{ESC} was due to safety measures, as the latter button is close to the mode definition keys. 

The main function of this mode is to permit the exiting of the main loop in the fpga. It also allows a faster shutting down of the engines as an emergency measure, in case \textit{panic/safe} mode are not an option. The exiting is done by incrementing the flag \texttt{program\_done}.

%-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%   Profiling
\subsection{Profiling}
\label{sec:profiling}
During the project, \textbf{Imara} profiled the software and made several improvements. Initially the entire sending of the telemetry costs 1738 $\mu$s. After employing a macro for writing to the circular buffer, this time was decreased to only 1310 $\mu$s. Finally when using the sending macro, this was decreased to 892 $\mu$s. The size of the packet eventually increased, but by sending a flag to indicate whether the engine values were all set to zero saved sending 4 bytes, to which the sending of the telemetry was finally reduced to 904 $\mu$s. In the same manner was the sending of a single byte reduced from 150 $\mu$s to 83 $\mu$s by using the \texttt{cbGet} macro. 

The filters were also drastically decreased in time. The butterworth filter was decreased from 1221 $\mu$s to 690 $\mu$s by using a macro for the fixed point arithmetic. This time could be even more decreased as it was initially computer for all sensor values. This was changed to only 2 sensors and ended up taking 252 $\mu$s.

The following profile was made of the software by using the internal clock defined as \texttt{X32\_us\_clock}. These values are measure with the \texttt{INTERRUPT\_XUFO}, the \texttt{INTERRUPT\_PRIMARY\_RX} and the \texttt{INTERRUPT\_PRIMARY\_TX} enabled. This means that these Interrupt Service Routines (ISRs) can inerrupt the code, causing a delay. These interrupts are required to be enabled to ensure complete code coverage.

\begin{table}[ht]
\centering
\begin{tabular}{|l|l|c|}
\hline 
\textbf{Function} & \textbf{Specific code} & \textbf{Time in $\mu$s} \\ 
\hline 
\texttt{if (commflag++ > commthres)} & & 17 \\
\hline
\texttt{decode()} & & 256 \\
\hline
 & \texttt{DISABLE\_INTERRUPT(INTERRUPT\_GLOBAL)} & 85 \\
 & \texttt{for loop()} & 105 \\
 & \texttt{ENABLE\_INTERRUPT(INTERRUPT\_GLOBAL)} & 130 \\
\hline
\texttt{check\_sum()} & & 168 \\
\hline
\texttt{isr\_rs232\_tx} & \texttt{toggle\_led()} & 17 \\
\hline
\texttt{isr\_rs232\_rx} & & 51 \\
\hline
 & \texttt{cbWritenoSum()} & 25 \\
\hline
\texttt{Safe mode} & & 499 \\
\hline
\texttt{Manual mode} & & 337 \\
\hline 
\texttt{Butterworth filter} & & 252 \\
\hline
\texttt{Kalman filter} & & 312 \\
\hline
\texttt{data\_store()} & & 1556 \\
\hline
\texttt{send\_telemetry()} & & 904 \\
\hline
\end{tabular} 
\caption{Profiling approximation of times}
\label{tbl:profiling}
\end{table}

The entire control loop excluding the periodic telemetry and datastoring results in a loop of 867 $\mu$s. 

%----------------------------------------------------------------------------------------
%	EXPERIMENTAL RESULTS
%	list the capabilities of your demonstrator
%----------------------------------------------------------------------------------------

\section{Experimental results}
\label{sec:results}
In this section we discuss what worked correctly and what did not during the final lab session. Some reasoning is applied to try to justify what caused those failures and understand what further work should be done in order to correct them.

The first test performed was to the mode change allowance possibilities. Here, it was verified that all the several safety requirements were fulfilled. Nonetheless, one issue was identified when the \textit{calibration mode} was selected and the automatic change back to safe state was not performed. Forcing a change by pressing '$0$' seemed to solve the issue and later when \textit{calibration mode} was called again, everything performed as expected. Although further debugging was needed to identify the issue source, it seemed to be related with a wrong initialization of the \texttt{TELEMETRY\_FLAG}.

The execution of the \textit{manual mode} worked perfectly, as the QR revealed an accordingly behaviour with the user references. It also showed a smooth performance in roll, pitch and yaw movements revealing the proficient tuning of the scaling functions. Nonetheless, some delay was noticed when evaluating the time interval between a user order and respective actuation. At this point we also had the chance to test the \textit{panic mode} and \textit{safe mode}, which executed their tasks as expected taking the QR to a safe and steady state. The following assessment was to the \textit{calibration mode}. We could notice that the sensors offset was found correctly since the user interface showed null values for the dynamic angles and rates after calibration and when one of the controlled modes was accessed.

At this point we were in condition of testing the \textit{yaw-controlled mode}. A first approach was done by leaving the yaw rate \texttt{r} set to 0 and applying a rotational disturbance to check if the reference was followed and attained. As shown in figure \ref{fig:YawControl}, the expected behaviour was accomplished since the QR rapidly rejected the disturbance and followed the reference.

\begin{figure}[ht]
\centering
	\includegraphics[trim = 0mm 50mm 0mm 40mm, scale = .5]{Figures/YawControl}
	\caption{Disturbance rejection in \textit{yaw-controlled mode}}
	\label{fig:YawControl}
\end{figure}

Despite this successfully test, when a different reference (provided by the joystick) was feed to the controller a strange behaviour was witnessed. Basically, the controller was assuming a symmetric reference to the one intended. The error here was identified in the dynamics inversion of the mode algorithm. The linearized dynamics were established using as convention a positive \textit{yaw momentum} \texttt{N} for a clockwise rotation (when looking from above the QR), while the reference yaw rate definition used the opposite definition. This issued could be easily solved by adding a minus sign to the \texttt{N} equation of the linearized system.

Since the group did not have the chance to properly tune the Filtering parameters it was decided not to test \textit{full control mode} since an unexpected and not safety behavior could be experienced. Nevertheless, assuming that the algorithm used clearly resembles the applied for the \textit{yaw-controlled mode}, we believe that it was correctly implemented.

%----------------------------------------------------------------------------------------
%	CONCLUSION
%	Evaluate the design, team results, individual performance and learning experience
%----------------------------------------------------------------------------------------

\section{Conclusion}
\label{sec:conclusion}

This project has been extremely valuable for all three of us. Because the fourth group member dropped out in week 2, it has been hard to keep up with the pace of the course. This caused an initial chaotic start as the team existed out of 1 Systems and Control Msc, 1 Biomechanical Engineering Phd and 1 former Industrial Design and current Embedded Systems Msc student. Although this initially created an unbalanced workload, it eventually spread out among the team members and ended up being a great learning experience. 

Although the design ended up flawed when in yaw-control mode, we feel like we learned from our mistakes. If we might have gotten a week extra, we would have had enough time to tweek the yaw-control into perfection as it was only available for testing in the final lab. If the yaw-control had been operable, it would have only been a few extra steps to have a successful full-control mode. 

We would have obviously liked to see the quadcopter hover, but it has already inspired team members to continue in similar projects and being able to do so because of the gained knowledge in the project is good enough for now. 


%----------------------------------------------------------------------------------------
%	APPENDIX
%----------------------------------------------------------------------------------------

%\newpage
%\section{Appendices}
%
%\appendix
%\section{Title of Appendix A}
%\section{Title of Appendix B}



%----------------------------------------------------------------------------------------

%\bibliographystyle{plain}
%\bibliography{report}

\end{document}
